import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:latlong2/latlong.dart';
import '../models/camera_report_model.dart';
import '../models/speed_camera_model.dart';
import 'dart:math' as math;

class CameraReportService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  static final FirebaseAuth _auth = FirebaseAuth.instance;

  // Collections
  static const String _reportsCollection = 'camera_reports';
  static const String _votesCollection = 'camera_votes';
  static const String _userStatsCollection = 'user_report_stats';

  /// Submit a new camera report
  static Future<String> submitReport({
    required double latitude,
    required double longitude,
    required String roadName,
    required int speedLimit,
    required CameraReportType type,
    String? description,
    String? imageUrl,
    List<String> tags = const [],
    String? selectedCameraId, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
  }) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('User not authenticated');

    // ‚ú® ‡∏™‡∏£‡πâ‡∏≤‡∏á Camera ID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
    String? cameraId;
    if (type == CameraReportType.newCamera) {
      cameraId = _firestore.collection('speed_cameras').doc().id;
      print('üÜï Generated new camera ID: $cameraId');
    }

    // ‚ú® ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö duplicate ‡πÅ‡∏ö‡∏ö‡∏ä‡∏≤‡∏ç‡∏â‡∏•‡∏≤‡∏î
    if (type == CameraReportType.removedCamera) {
      // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ñ‡∏≠‡∏ô" - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Camera ID ‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
      if (selectedCameraId == null) {
        throw Exception('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà');
      }

      final existingRemovalReports = await _firestore
          .collection(_reportsCollection)
          .where('type', isEqualTo: 'removedCamera')
          .where('selectedCameraId', isEqualTo: selectedCameraId)
          .where('status', whereIn: ['pending', 'verified']).get();

      if (existingRemovalReports.docs.isNotEmpty) {
        throw Exception('‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ñ‡∏≠‡∏î‡πÅ‡∏•‡πâ‡∏ß');
      }
    } else if (type == CameraReportType.speedChanged) {
      // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß" - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Camera ID ‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
      if (selectedCameraId == null) {
        throw Exception('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà');
      }

      final existingSpeedChangeReports = await _firestore
          .collection(_reportsCollection)
          .where('type', isEqualTo: 'speedChanged')
          .where('selectedCameraId', isEqualTo: selectedCameraId)
          .where('status', whereIn: ['pending', 'verified']).get();

      if (existingSpeedChangeReports.docs.isNotEmpty) {
        throw Exception('‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß');
      }
    } else {
      // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà" - ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏±‡∏®‡∏°‡∏µ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ compound index)
      final nearbyNewCameraReports =
          await _findNearbyNewCameraReports(latitude, longitude, 50);
      if (nearbyNewCameraReports.isNotEmpty) {
        throw Exception(
            '‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏ö‡∏£‡∏¥‡πÄ‡∏ß‡∏ì‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
      }
    }

    final reportId = _firestore.collection(_reportsCollection).doc().id;
    final report = CameraReport(
      id: reportId,
      latitude: latitude,
      longitude: longitude,
      roadName: roadName,
      speedLimit: speedLimit,
      reportedBy: user.uid,
      reportedAt: DateTime.now(),
      type: type,
      description: description,
      imageUrl: imageUrl,
      tags: tags,
      selectedCameraId: type == CameraReportType.newCamera
          ? cameraId
          : selectedCameraId, // ‡πÉ‡∏ä‡πâ Camera ID ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
    );

    await _firestore
        .collection(_reportsCollection)
        .doc(reportId)
        .set(report.toJson());

    print('‚úÖ New camera report created: ${report.roadName} (ID: $reportId)');
    print('üìä Report details:');
    print('   Status: ${report.status}');
    print('   Type: ${report.type}');
    print('   Latitude: ${report.latitude}');
    print('   Longitude: ${report.longitude}');
    print('   Reported by: ${report.reportedBy}');
    print('   Reported at: ${report.reportedAt}');
    print('   Camera ID: ${report.selectedCameraId}');

    // ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    // ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏ß‡∏ï‡∏Ñ‡∏£‡∏ö 3 ‡∏Ñ‡∏ô‡∏Å‡πà‡∏≠‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ú‡πà‡∏≤‡∏ô auto-promotion
    print(
        'üìã Camera will be created after receiving 3+ votes and verification');

    // Verify the document was saved correctly
    try {
      await Future.delayed(const Duration(milliseconds: 500));
      final savedDoc = await _firestore
          .collection(_reportsCollection)
          .doc(reportId)
          .get(const GetOptions(source: Source.server));

      if (savedDoc.exists) {
        final savedData = savedDoc.data()!;
        print('‚úÖ Verification: Document saved successfully');
        print('   Saved status: ${savedData['status']}');
        print('   Saved type: ${savedData['type']}');
        print('   Document exists: true');
      } else {
        print('‚ùå Warning: Document not found after save');
      }
    } catch (e) {
      print('‚ö†Ô∏è Could not verify document save: $e');
    }

    // Update user stats
    await _updateUserStats(user.uid, 'reports_submitted');

    return reportId;
  }

  /// Submit a vote for a camera report
  static Future<void> submitVote({
    required String reportId,
    required VoteType voteType,
    String? comment,
    int maxRetries = 2, // ‡πÄ‡∏û‡∏¥‡πà‡∏° retry mechanism
  }) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏Å‡πà‡∏≠‡∏ô');

    // Debug user info
    print('üîç DEBUG - User info:');
    print('   User ID: ${user.uid}');
    print('   Email: ${user.email}');
    print('   Is Anonymous: ${user.isAnonymous}');
    print('   Display Name: ${user.displayName}');
    print('   Auth Token: ${user.refreshToken != null ? "Available" : "None"}');

    Exception? lastError;

    // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÇ‡∏´‡∏ß‡∏ï‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î maxRetries + 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
    for (int attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          print('üîÑ Vote retry attempt $attempt of $maxRetries');
          // ‡∏£‡∏≠‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡πà‡∏≠‡∏ô retry
          await Future.delayed(Duration(milliseconds: 1000 * attempt));

          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö auth token ‡πÉ‡∏´‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô retry
          await user.getIdToken(true); // Force refresh token
          print('üîê Auth token refreshed for retry');
        }

        print(
            'üó≥Ô∏è Starting vote submission for user: ${user.uid} (attempt ${attempt + 1})');

        // Check if user has already voted (FORCE SERVER CHECK - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ cache)
        print('üîç Checking if user has already voted (from server)...');
        final existingVote = await _firestore
            .collection(_votesCollection)
            .where('reportId', isEqualTo: reportId)
            .where('userId', isEqualTo: user.uid)
            .get(const GetOptions(source: Source.server)) // FORCE SERVER
            .timeout(const Duration(seconds: 15));

        if (existingVote.docs.isNotEmpty) {
          print(
              '‚ùå User has already voted - vote ID: ${existingVote.docs.first.id}');
          throw Exception('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÇ‡∏´‡∏ß‡∏ï‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß');
        }

        print('‚úÖ Vote check passed - user has not voted yet');

        // Check if report exists first (FORCE SERVER CHECK)
        print('üîç Checking if report exists (from server)...');
        final reportDoc = await _firestore
            .collection(_reportsCollection)
            .doc(reportId)
            .get(const GetOptions(source: Source.server)) // FORCE SERVER
            .timeout(const Duration(seconds: 15));

        if (!reportDoc.exists) {
          throw Exception('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ ‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß');
        }

        final report = CameraReport.fromJson(reportDoc.data()!);

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
        if (report.status != CameraStatus.pending) {
          throw Exception('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏ß‡∏ï‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending ‡πÑ‡∏î‡πâ');
        }

        print('‚úÖ Report exists and is pending - proceeding with vote');
        print(
            'üìä Report details: ${report.roadName}, Status: ${report.status}');

        final voteId = _firestore.collection(_votesCollection).doc().id;
        final vote = CameraVote(
          id: voteId,
          reportId: reportId,
          userId: user.uid,
          voteType: voteType,
          votedAt: DateTime.now(),
          comment: comment,
        );

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏™‡∏£‡πâ‡∏≤‡∏á vote ‡∏Å‡πà‡∏≠‡∏ô (with timeout)
        print('üìù Creating vote document...');
        await _firestore
            .collection(_votesCollection)
            .doc(voteId)
            .set(vote.toJson())
            .timeout(const Duration(seconds: 15));
        print('‚úÖ Vote document created successfully');

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï report counts ‡πÅ‡∏¢‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏≤‡∏Å
        print('üìä Updating report vote counts...');
        await _updateReportVoteCounts(reportId, voteType);
        print('‚úÖ Report vote counts updated successfully');

        // Update user stats (with timeout)
        print('üìà Updating user stats...');
        await _updateUserStats(user.uid, 'votes_submitted')
            .timeout(const Duration(seconds: 15));
        print('‚úÖ User stats updated successfully');

        // If auto-verified, potentially add to main speed camera database
        print('üîç Checking if report was auto-verified...');
        final isAutoVerified = await _isReportAutoVerified(reportId);
        print('üìä Auto-verification result: $isAutoVerified');

        if (isAutoVerified) {
          print('üéØ Report auto-verified - promoting to main database');
          try {
            await _promoteToMainDatabase(reportId);
            print('‚úÖ Promotion completed successfully');
          } catch (e) {
            print('‚ùå Error during promotion: $e');
            // Log the error but don't fail the vote
          }
        } else {
          print('‚è≥ Report not yet auto-verified - skipping promotion');
        }

        print('üéâ Vote submission completed successfully');
        return; // ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å loop
      } catch (e) {
        lastError = Exception(e.toString());
        print('‚ùå Vote attempt ${attempt + 1} failed: $e');
        print('üîç Error type: ${e.runtimeType}');

        // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î error ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        if (e.toString().contains('permission-denied')) {
          print('üö´ Permission denied details:');
          print('   Current user: ${user.uid}');
          print('   User email: ${user.email ?? "No email"}');
          print('   Is authenticated: ${user.uid.isNotEmpty}');
          print('   Report ID: $reportId');
        }

        // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô error ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£ retry ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        if (e.toString().contains('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÇ‡∏´‡∏ß‡∏ï‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß') ||
            e.toString().contains('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ') ||
            e.toString().contains('‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending')) {
          print('üí° Non-retryable error - stopping retries');
          break;
        }

        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡∏°‡∏µ attempt ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô error ‡∏ó‡∏µ‡πà retry ‡πÑ‡∏î‡πâ
        if (attempt < maxRetries) {
          print('üîÑ Will retry in ${1000 * (attempt + 1)}ms...');
          continue;
        }
      }
    }

    // ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡πÅ‡∏õ‡∏•‡∏ß‡πà‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    print('üí• All vote attempts failed');
    print('üîç Last error: ${lastError?.toString()}');

    // ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• error ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô
    if (lastError != null) {
      final errorMsg = lastError.toString();
      if (errorMsg.contains('permission-denied')) {
        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö permission error
        print('üö´ Permission denied - Debug info:');
        print('   User authenticated: ${user.uid.isNotEmpty}');
        print('   User email: ${user.email}');
        print('   Report ID: $reportId');

        throw Exception(
            '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏ß‡∏ï - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡πÉ‡∏´‡∏°‡πà');
      } else if (errorMsg.contains('not-found')) {
        throw Exception('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ ‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß');
      } else if (errorMsg.contains('network') ||
          errorMsg.contains('timeout') ||
          errorMsg.contains('TimeoutException')) {
        throw Exception('‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
      } else if (errorMsg.contains('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÇ‡∏´‡∏ß‡∏ï‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß')) {
        throw Exception('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÇ‡∏´‡∏ß‡∏ï‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß');
      } else {
        throw Exception(
            '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏ß‡∏ï‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: ${errorMsg.length > 100 ? errorMsg.substring(0, 100) + "..." : errorMsg}');
      }
    } else {
      throw Exception('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏ß‡∏ï‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
    }
  }

  /// Update report vote counts separately (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ transaction)
  static Future<void> _updateReportVoteCounts(
      String reportId, VoteType voteType) async {
    try {
      final reportRef = _firestore.collection(_reportsCollection).doc(reportId);
      final reportDoc = await reportRef.get(const GetOptions(source: Source.server));

      if (!reportDoc.exists) throw Exception('Report not found');

      final report = CameraReport.fromJson(reportDoc.data()!);
      final newUpvotes = voteType == VoteType.upvote ? report.upvotes + 1 : report.upvotes;
      final newDownvotes = voteType == VoteType.downvote ? report.downvotes + 1 : report.downvotes;
      final newTotalVotes = newUpvotes + newDownvotes;
      final newConfidenceScore = newTotalVotes > 0 ? newUpvotes / newTotalVotes : 0.0;

      print('üìä Vote Count Update: Upvotes: $newUpvotes, Downvotes: $newDownvotes, Total: $newTotalVotes, Confidence: ${(newConfidenceScore * 100).toStringAsFixed(1)}%');

      // Auto-verify logic
      if (newTotalVotes >= 3) {
        final updateData = {
          'upvotes': newUpvotes,
          'downvotes': newDownvotes,
          'confidenceScore': newConfidenceScore,
        };

        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö newCamera
        if (report.type == CameraReportType.newCamera && newConfidenceScore >= 0.7) {
          updateData['status'] = 'verified';
          updateData['verifiedAt'] = FieldValue.serverTimestamp();
          updateData['verifiedBy'] = 'auto_system';

          await reportRef.update(updateData);
          print('‚úÖ Report verified - attempting to promote to main database');
          await _promoteToMainDatabase(reportId); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á verify
          return;
        }

        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö speedChanged
        if (report.type == CameraReportType.speedChanged) {
          if (newConfidenceScore >= 0.7) {
            updateData['status'] = 'verified';
            updateData['verifiedAt'] = FieldValue.serverTimestamp();
            updateData['verifiedBy'] = 'auto_system';
            
            await reportRef.update(updateData);
            print('‚úÖ Speed change report verified');
            await _updateCameraSpeedLimit(report);
            return;
          } else if (newConfidenceScore <= 0.3) {
            updateData['status'] = 'rejected';
            updateData['verifiedAt'] = FieldValue.serverTimestamp();
            updateData['verifiedBy'] = 'auto_system';
          }
        }

        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö removedCamera
        if (report.type == CameraReportType.removedCamera && newConfidenceScore >= 0.7) {
          updateData['status'] = 'verified';
          updateData['verifiedAt'] = FieldValue.serverTimestamp();
          updateData['verifiedBy'] = 'auto_system';

          await reportRef.update(updateData);
          print('‚úÖ Camera removal report verified');
          await _handleCameraRemovalReport(report);
          return;
        }

        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏Å‡∏ï‡∏¥
        await reportRef.update(updateData);
      } else {
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏â‡∏û‡∏≤‡∏∞ vote counts
        await reportRef.update({
          'upvotes': newUpvotes,
          'downvotes': newDownvotes,
          'confidenceScore': newConfidenceScore,
        });
      }
    } catch (e) {
      print('‚ùå Error updating vote counts: $e');
      rethrow;
    }
  }

            // ‚ú® ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Firebase ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            if (report.type == CameraReportType.removedCamera) {
              print('üóëÔ∏è === CAMERA REMOVAL TRIGGERED ===');
              print('Report ID: $reportId');
              print('Selected Camera ID: ${report.selectedCameraId}');

              try {
                String? cameraId = report.selectedCameraId;

                if (cameraId != null && cameraId.isNotEmpty) {
                  print('üéØ Deleting camera ID: $cameraId');
                  await _directDeleteCameraWithRetry(cameraId);

                  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                  final isDeleted = await _verifyCameraDeletion(cameraId);
                  if (isDeleted) {
                    print(
                        '‚úÖ Camera $cameraId deleted and verified successfully');
                  } else {
                    throw Exception(
                        'Camera $cameraId still exists after deletion');
                  }
                } else {
                  print(
                      '‚ö†Ô∏è No camera ID specified - trying location-based deletion');
                  await _deleteByLocation(report.latitude, report.longitude);
                }
              } catch (e) {
                print('‚ùå Error deleting camera: $e');
                // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error ‡∏•‡∏á‡πÉ‡∏ô collection ‡∏û‡∏¥‡πÄ‡∏®‡∏©
                await _logDeletionError(
                    reportId, report.selectedCameraId, e.toString());
                // ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ error ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Ç‡∏±‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
              }
            }
          } else if (newConfidenceScore <= 0.2) {
            newStatus = CameraStatus.rejected;
            verifiedAt = DateTime.now();
            verifiedBy = 'auto_system';
            print(
                '‚ùå Auto-rejecting report due to low confidence (${(newConfidenceScore * 100).toStringAsFixed(1)}%) with $newTotalVotes votes');
          } else {
            print(
                '‚è≥ Report still pending - confidence ${(newConfidenceScore * 100).toStringAsFixed(1)}% (need >= 80% or <= 20%)');
          }
        }
      } else {
        print('‚è≥ Not enough votes yet for auto-verification');
      }

      // Update report ‡∏î‡πâ‡∏ß‡∏¢ merge: true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ó‡∏±‡∏ö
      final updateData = {
        'upvotes': newUpvotes,
        'downvotes': newDownvotes,
        'confidenceScore': newConfidenceScore,
        'status': newStatus.toString().split('.').last,
        if (verifiedAt != null) 'verifiedAt': verifiedAt.toIso8601String(),
        if (verifiedBy != null) 'verifiedBy': verifiedBy,
      };

      print('üîÑ Updating report with new vote counts...');
      print('üìä Update data: $updateData');
      await reportRef.update(updateData);
      print('‚úÖ Report vote counts updated successfully');

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      final updatedDoc =
          await reportRef.get(const GetOptions(source: Source.server));
      if (updatedDoc.exists) {
        final updatedData = updatedDoc.data() as Map<String, dynamic>;
        print('‚úÖ Verification - Updated report data: {');
        print('   status: ${updatedData['status']}');
        print('   upvotes: ${updatedData['upvotes']}');
        print('   downvotes: ${updatedData['downvotes']}');
        print('   confidenceScore: ${updatedData['confidenceScore']}');
        print('   verifiedAt: ${updatedData['verifiedAt']}');
        print('   verifiedBy: ${updatedData['verifiedBy']}');
        print('}');
      } else {
        print('‚ùå Warning: Could not verify report update');
      }
    } catch (e) {
      print('‚ùå Error updating report vote counts: $e');

      // ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• error ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô
      if (e.toString().contains('permission-denied')) {
        throw Exception('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÇ‡∏´‡∏ß‡∏ï');
      } else if (e.toString().contains('not-found')) {
        throw Exception('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï');
      } else {
        throw Exception('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÇ‡∏´‡∏ß‡∏ï‡πÑ‡∏î‡πâ: ${e.toString()}');
      }
    }
  }

  /// Get pending reports that need votes (ALWAYS FORCE REFRESH)
  static Future<List<CameraReport>> getPendingReports({
    double? userLat,
    double? userLng,
    double radiusKm =
        1000.0, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 50 ‡πÄ‡∏õ‡πá‡∏ô 1000 km (‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢)
    int limit = 50, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 50 ‡πÇ‡∏û‡∏™‡∏ï‡πå
    bool forceRefresh = true, // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    bool showAllNationwide = false, // ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®
  }) async {
    print('üîç === GET PENDING REPORTS START ===');
    print('üîç getPendingReports called with:');
    print('   userLat: $userLat, userLng: $userLng');
    print('   radiusKm: $radiusKm, limit: $limit');
    print('   forceRefresh: $forceRefresh');
    print('   showAllNationwide: $showAllNationwide');

    try {
      Query query = _firestore
          .collection(_reportsCollection)
          .where('status', isEqualTo: 'pending')
          .orderBy('reportedAt', descending: true)
          .limit(limit);

      print('üîç Executing Firestore query...');

      // ALWAYS FORCE REFRESH ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡πÇ‡∏û‡∏™‡∏ï‡πå‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
      final snapshot = await query.get(const GetOptions(source: Source.server));

      print('üìä Firestore query result: ${snapshot.docs.length} documents');

      if (snapshot.docs.isEmpty) {
        print('‚ö†Ô∏è No pending reports found in Firestore');
        print('üîç Checking if there are any reports at all...');

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        final allReportsQuery = _firestore
            .collection(_reportsCollection)
            .orderBy('reportedAt', descending: true)
            .limit(5);

        final allReportsSnapshot =
            await allReportsQuery.get(const GetOptions(source: Source.server));
        print(
            'üìä Total reports in database: ${allReportsSnapshot.docs.length}');

        for (final doc in allReportsSnapshot.docs) {
          final data = doc.data() as Map<String, dynamic>?;
          if (data != null) {
            print(
                '   Report: ${data['roadName']} - Status: ${data['status']} - Type: ${data['type']}');
          }
        }
      }

      final reports = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>?;
        if (data == null) {
          print('   ‚ùå Document ${doc.id} has null data');
          throw Exception('Document data is null');
        }

        print('üìÑ Processing document:');
        print('   Document ID: ${doc.id}');
        print('   Status: ${data['status']}');
        print('   Type: ${data['type']}');
        print('   Road: ${data['roadName']}');
        print('   Reported at: ${data['reportedAt']}');
        print('   Reported by: ${data['reportedBy']}');

        try {
          final report = CameraReport.fromJson(data);
          print('   ‚úÖ Successfully converted to CameraReport');
          return report;
        } catch (e) {
          print('   ‚ùå Error converting to CameraReport: $e');
          print('   ‚ùå Raw data: $data');
          rethrow;
        }
      }).toList();

      print('üìã Converted to ${reports.length} CameraReport objects');

      // Filter by distance if user location provided
      if (userLat != null && userLng != null && !showAllNationwide) {
        final originalCount = reports.length;
        print(
            'üìç Applying distance filter with user location: ($userLat, $userLng)');
        print('üìç Radius limit: ${radiusKm}km');

        // Debug: Check distances for all reports
        for (int i = 0; i < reports.length; i++) {
          final report = reports[i];
          final distance = _calculateDistance(
              userLat, userLng, report.latitude, report.longitude);
          print(
              '   Report ${i + 1}: ${report.roadName} - Distance: ${distance.toStringAsFixed(2)}km');
        }

        reports.removeWhere((report) {
          final distance = _calculateDistance(
              userLat, userLng, report.latitude, report.longitude);
          final tooFar = distance > radiusKm;
          if (tooFar) {
            print(
                '   ‚ùå Filtering out ${report.roadName} - ${distance.toStringAsFixed(2)}km > ${radiusKm}km');
          }
          return tooFar;
        });
        print(
            'üìç Distance filter: ${originalCount} -> ${reports.length} reports (within ${radiusKm}km)');
      } else if (showAllNationwide) {
        print('üåè Showing all reports nationwide - no distance filter applied');
      } else {
        print('üìç No user location provided - skipping distance filter');
      }

      print('‚úÖ Final result: ${reports.length} pending reports');
      print('üîç === GET PENDING REPORTS END ===');

      return reports;
    } catch (e) {
      print('‚ùå Error in getPendingReports: $e');
      print('‚ùå Error type: ${e.runtimeType}');
      print('‚ùå Stack trace: ${StackTrace.current}');
      rethrow;
    }
  }

  /// Get user's voting history (FORCE FROM SERVER)
  static Future<List<String>> getUserVotedReports() async {
    final user = _auth.currentUser;
    if (user == null) return [];

    // FORCE SERVER READ - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ cache ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
    final snapshot = await _firestore
        .collection(_votesCollection)
        .where('userId', isEqualTo: user.uid)
        .get(const GetOptions(source: Source.server));

    final votedReports =
        snapshot.docs.map((doc) => doc['reportId'] as String).toList();
    print(
        'üìä User voted reports (from server): ${votedReports.length} reports');

    return votedReports;
  }

  /// Get user's report statistics
  static Future<Map<String, int>> getUserStats() async {
    final user = _auth.currentUser;
    if (user == null) return {};

    final doc =
        await _firestore.collection(_userStatsCollection).doc(user.uid).get();

    if (!doc.exists) return {};

    return Map<String, int>.from(doc.data() ?? {});
  }

  /// Find nearby NEW camera reports within specified radius (simplified - no compound index required)
  static Future<List<CameraReport>> _findNearbyNewCameraReports(
      double lat, double lng, double radiusMeters) async {
    // Simple approach: Get all newCamera reports and filter by distance in Dart
    // This avoids complex compound Firestore queries that need special indexes

    print('üîç Searching for nearby new camera reports...');
    print('   Center: ($lat, $lng)');
    print('   Radius: ${radiusMeters}m');

    final snapshot = await _firestore
        .collection(_reportsCollection)
        .where('type', isEqualTo: 'newCamera')
        .where('status',
            whereIn: ['pending', 'verified']) // Only these 2 statuses
        .get();

    print('üìä Found ${snapshot.docs.length} newCamera reports to check');

    final reports = <CameraReport>[];

    for (final doc in snapshot.docs) {
      try {
        final report = CameraReport.fromJson(doc.data());
        final distance =
            _calculateDistance(lat, lng, report.latitude, report.longitude);
        final distanceInMeters = distance * 1000;

        print(
            '   Report: ${report.roadName} - Distance: ${distanceInMeters.toStringAsFixed(2)}m');

        if (distanceInMeters <= radiusMeters) {
          reports.add(report);
          print('   ‚úÖ Within radius - added to results');
        } else {
          print('   ‚ùå Too far - skipped');
        }
      } catch (e) {
        print('   ‚ö†Ô∏è Error processing report ${doc.id}: $e');
      }
    }

    print(
        'üéØ Found ${reports.length} nearby new camera reports within ${radiusMeters}m');
    return reports;
  }

  /// Calculate distance between two points (in kilometers)
  static double _calculateDistance(
      double lat1, double lng1, double lat2, double lng2) {
    const earthRadius = 6371; // Earth's radius in kilometers

    final dLat = (lat2 - lat1) * math.pi / 180;
    final dLng = (lng2 - lng1) * math.pi / 180;

    final a = math.sin(dLat / 2) * math.sin(dLat / 2) +
        math.cos(lat1 * math.pi / 180) *
            math.cos(lat2 * math.pi / 180) *
            math.sin(dLng / 2) *
            math.sin(dLng / 2);

    final c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a));
    return earthRadius * c;
  }

  /// Update user statistics
  static Future<void> _updateUserStats(String userId, String statKey) async {
    final docRef = _firestore.collection(_userStatsCollection).doc(userId);

    await _firestore.runTransaction((transaction) async {
      final doc = await transaction.get(docRef);

      final currentStats =
          doc.exists ? Map<String, int>.from(doc.data()!) : <String, int>{};
      currentStats[statKey] = (currentStats[statKey] ?? 0) + 1;
      currentStats['total_contributions'] =
          (currentStats['total_contributions'] ?? 0) + 1;
      currentStats['last_activity'] = DateTime.now().millisecondsSinceEpoch;

      transaction.set(docRef, currentStats, SetOptions(merge: true));
    });
  }

  /// Check if report is auto-verified
  static Future<bool> _isReportAutoVerified(String reportId) async {
    print('üîç Checking auto-verification status for report: $reportId');

    try {
      final doc = await _firestore
          .collection(_reportsCollection)
          .doc(reportId)
          .get(const GetOptions(source: Source.server)); // Force server read

      if (!doc.exists) {
        print('‚ùå Report $reportId not found for auto-verification check');
        return false;
      }

      final report = CameraReport.fromJson(doc.data()!);
      final isAutoVerified = report.status == CameraStatus.verified &&
          report.verifiedBy == 'auto_system';

      print('üìä Auto-verification check result:');
      print('   Report ID: $reportId');
      print('   Status: ${report.status}');
      print('   Verified by: ${report.verifiedBy}');
      print('   Is auto-verified: $isAutoVerified');
      print('   Report type: ${report.type}');
      print('   Confidence: ${report.confidenceScore}');

      return isAutoVerified;
    } catch (e) {
      print('‚ùå Error checking auto-verification for $reportId: $e');
      return false;
    }
  }

  /// Promote verified report to main speed camera database
  static Future<void> _promoteToMainDatabase(String reportId) async {
    try {
      print('üöÄ === PROMOTION PROCESS START ===');
      print('üöÄ Attempting to promote report $reportId to main database');

      final doc = await _firestore
          .collection(_reportsCollection)
          .doc(reportId)
          .get(const GetOptions(source: Source.server)); // Force server read

      if (!doc.exists) {
        print('‚ùå Report $reportId not found - cannot promote');
        return;
      }

      final report = CameraReport.fromJson(doc.data()!);
      print('üìä Report details for promotion:');
      print('   Report ID: $reportId');
      print('   Status: ${report.status}');
      print('   Type: ${report.type}');
      print('   Verified by: ${report.verifiedBy}');
      print('   Road: ${report.roadName}');
      print('   Location: (${report.latitude}, ${report.longitude})');
      print('   Confidence: ${report.confidenceScore}');
      print('   Speed Limit: ${report.speedLimit}');
      print('   Camera ID: ${report.selectedCameraId}');
      print('   Total Votes: ${report.totalVotes}');

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏Ç‡∏±‡πâ‡∏ô
      if (report.status != CameraStatus.verified) {
        print('‚ùå Report status is not verified: ${report.status}');
        return;
      }

      if (report.verifiedBy != 'auto_system') {
        print('‚ùå Report not verified by auto system: ${report.verifiedBy}');
        return;
      }

      // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
      if (report.type == CameraReportType.removedCamera) {
        print('üóëÔ∏è Processing REMOVED CAMERA report');
        await _handleCameraRemovalReport(report);
        return;
      }

      if (report.type == CameraReportType.speedChanged) {
        print('‚ö° Processing SPEED CHANGED report');
        await _updateCameraSpeedLimit(report);
        return;
      }

      if (report.type != CameraReportType.newCamera) {
        print('‚ùå Report type is not newCamera: ${report.type}');
        return;
      }

      print('üèóÔ∏è Creating new camera from verified report...');

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏ß‡∏ï‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 votes)
      if (report.totalVotes < 3) {
        print(
            '‚ùå Not enough votes for camera creation: ${report.totalVotes} votes (need at least 3)');
        return;
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ 100 ‡πÄ‡∏°‡∏ï‡∏£‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      print('üîç Checking for duplicate cameras within 100m...');
      final nearbyCameras = await getAllSpeedCameras();
      print('üìä Found ${nearbyCameras.length} existing cameras to check');

      bool hasDuplicate = false;
      String? duplicateInfo;

      for (final camera in nearbyCameras) {
        final distance = _calculateDistance(
          report.latitude,
          report.longitude,
          camera.location.latitude,
          camera.location.longitude,
        );
        final distanceInMeters = distance * 1000;

        print(
            '   Camera: ${camera.roadName} - Distance: ${distanceInMeters.toStringAsFixed(2)}m');

        if (distanceInMeters <= 100) {
          hasDuplicate = true;
          duplicateInfo =
              '${camera.roadName} (${camera.id}) at ${distanceInMeters.toStringAsFixed(2)}m';
          print('‚ö†Ô∏è Duplicate camera found within 100m:');
          print(
              '   Existing: ${camera.roadName} at (${camera.location.latitude}, ${camera.location.longitude})');
          print('   Distance: ${distanceInMeters.toStringAsFixed(2)}m');
          print('   Duplicate camera ID: ${camera.id}');
          break;
        }
      }

      if (hasDuplicate) {
        print('‚ö†Ô∏è Duplicate camera found within 100m - skipping promotion');
        print('‚ö†Ô∏è Duplicate info: $duplicateInfo');
        return;
      }

      print('‚úÖ No duplicate cameras found - proceeding with promotion');

      // ‡πÉ‡∏ä‡πâ Camera ID ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô
      final cameraId = report.selectedCameraId;
      if (cameraId == null || cameraId.isEmpty) {
        print('‚ùå No camera ID found in report - cannot create camera');
        return;
      }

      print('üèóÔ∏è Creating new camera with ID: $cameraId');

      final speedCamera = SpeedCamera(
        id: cameraId,
        location: LatLng(report.latitude, report.longitude),
        speedLimit: report.speedLimit,
        roadName: report.roadName,
        type: CameraType.fixed,
        isActive: true,
        description:
            'Community verified camera (${report.confidenceScore.toStringAsFixed(2)} confidence, ${report.totalVotes} votes)',
      );

      final cameraData = {
        ...speedCamera.toJson(),
        'verifiedAt': FieldValue.serverTimestamp(),
        'sourceReportId': report.id,
        'createdFromCommunityReport': true,
      };

      print('üìù Camera data to save:');
      print('   ID: ${speedCamera.id}');
      print('   Road: ${speedCamera.roadName}');
      print(
          '   Location: (${speedCamera.location.latitude}, ${speedCamera.location.longitude})');
      print('   Speed Limit: ${speedCamera.speedLimit}');
      print('   Type: ${speedCamera.type}');
      print('   Is Active: ${speedCamera.isActive}');
      print('   Description: ${speedCamera.description}');

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
      print('üíæ Saving camera to Firebase...');
      await _firestore
          .collection('speed_cameras')
          .doc(cameraId)
          .set(cameraData);

      print(
          'üéâ Successfully promoted report $reportId to main database as camera $cameraId');
      print(
          'üìç Camera location: ${report.roadName} (${report.latitude}, ${report.longitude})');

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢ server read
      print('üîç Verifying camera was saved successfully...');
      final savedCamera = await _firestore
          .collection('speed_cameras')
          .doc(cameraId)
          .get(const GetOptions(source: Source.server));

      if (savedCamera.exists) {
        print('‚úÖ Camera successfully saved to Firebase');
        final savedData = savedCamera.data() as Map<String, dynamic>;
        print('üìä Saved camera verification:');
        print('   ID: ${savedData['id']}');
        print('   Road: ${savedData['roadName']}');
        print('   Speed Limit: ${savedData['speedLimit']}');
        print('   Is Active: ${savedData['isActive']}');
        print('   Location Object: ${savedData['location']}');
        print('   Latitude: ${savedData['latitude']}');
        print('   Longitude: ${savedData['longitude']}');

        // Force refresh speed camera service
        print('üîÑ Requesting speed camera service refresh...');
        try {
          // Call speed camera service to refresh data
          final refreshedCameras = await getAllSpeedCameras(forceRefresh: true);
          print(
              '‚úÖ Speed camera refresh completed - found ${refreshedCameras.length} cameras');
        } catch (e) {
          print('‚ö†Ô∏è Could not refresh speed camera service: $e');
        }
      } else {
        print(
            '‚ùå Failed to save camera to Firebase - camera not found after save');
      }
      print('üöÄ === PROMOTION PROCESS COMPLETE ===');
    } catch (e) {
      print('‚ùå Error promoting report $reportId to main database: $e');
      print('üîç Error stack trace: ${e.toString()}');
      print('üîç Error type: ${e.runtimeType}');

      if (e.toString().contains('permission-denied')) {
        print('üö´ Permission denied - check Firestore security rules');
      } else if (e.toString().contains('not-found')) {
        print(
            'üîç Document not found - check collection names and document IDs');
      }

      // Re-throw the error for debugging but don't fail the entire vote process
      throw Exception('Promotion failed: ${e.toString()}');
    }
  }

  /// Get all speed cameras from main database (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á)
  static Future<List<SpeedCamera>> getAllSpeedCameras({
    double? userLat,
    double? userLng,
    double radiusKm =
        1000.0, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 50 ‡πÄ‡∏õ‡πá‡∏ô 1000 km (‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢)
    bool forceRefresh = true,
    bool showAllNationwide = false, // ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®
  }) async {
    print('üîç getAllSpeedCameras called with radius: ${radiusKm}km');
    print('üåè Show all nationwide: $showAllNationwide');

    // ‡πÉ‡∏ä‡πâ query ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á compound index
    Query query = _firestore
        .collection('speed_cameras')
        .where('isActive', isEqualTo: true);

    final snapshot = await query
        .get(forceRefresh ? const GetOptions(source: Source.server) : null);

    print('üìä Speed cameras query result: ${snapshot.docs.length} cameras');

    final cameras = snapshot.docs.map((doc) {
      final data = doc.data() as Map<String, dynamic>;
      print('   Camera: ${data['roadName']} - ${data['description']}');
      return SpeedCamera.fromJson(data);
    }).toList();

    // ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° roadName ‡πÉ‡∏ô Dart ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ orderBy ‡πÉ‡∏ô Firestore
    cameras.sort((a, b) => a.roadName.compareTo(b.roadName));

    // Filter by distance if user location provided
    if (userLat != null && userLng != null && !showAllNationwide) {
      final originalCount = cameras.length;
      cameras.removeWhere((camera) {
        final distance = _calculateDistance(userLat, userLng,
            camera.location.latitude, camera.location.longitude);
        return distance > radiusKm;
      });
      print(
          'üìç Distance filter: ${originalCount} -> ${cameras.length} cameras (within ${radiusKm}km)');
    } else if (showAllNationwide) {
      print('üåè Showing all cameras nationwide - no distance filter applied');
    }

    return cameras;
  }

  /// Get verified reports (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏ß‡∏ï‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á)
  static Future<List<CameraReport>> getVerifiedReports({
    double? userLat,
    double? userLng,
    double radiusKm =
        1000.0, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 50 ‡πÄ‡∏õ‡πá‡∏ô 1000 km (‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢)
    int limit = 50, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 50 ‡πÇ‡∏û‡∏™‡∏ï‡πå
    bool forceRefresh = true,
    bool showAllNationwide = false, // ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®
  }) async {
    print('üîç getVerifiedReports called with radius: ${radiusKm}km');
    print('üåè Show all nationwide: $showAllNationwide');

    Query query = _firestore
        .collection(_reportsCollection)
        .where('status', isEqualTo: 'verified')
        .orderBy('verifiedAt', descending: true)
        .limit(limit);

    final snapshot = await query
        .get(forceRefresh ? const GetOptions(source: Source.server) : null);

    print(
        'üìä Verified reports query result: ${snapshot.docs.length} documents');

    final reports = snapshot.docs.map((doc) {
      final data = doc.data() as Map<String, dynamic>;
      print('   Verified Report: ${data['roadName']} - ${data['verifiedAt']}');
      return CameraReport.fromJson(data);
    }).toList();

    // Filter by distance if user location provided
    if (userLat != null && userLng != null && !showAllNationwide) {
      final originalCount = reports.length;
      reports.removeWhere((report) {
        final distance = _calculateDistance(
            userLat, userLng, report.latitude, report.longitude);
        return distance > radiusKm;
      });
      print(
          'üìç Distance filter: ${originalCount} -> ${reports.length} verified reports (within ${radiusKm}km)');
    } else if (showAllNationwide) {
      print(
          'üåè Showing all verified reports nationwide - no distance filter applied');
    }

    return reports;
  }

  /// Get reports by status
  static Future<List<CameraReport>> getReportsByStatus(CameraStatus status,
      {bool forceRefresh = false}) async {
    final query = _firestore
        .collection(_reportsCollection)
        .where('status', isEqualTo: status.toString().split('.').last)
        .orderBy('reportedAt', descending: true);

    // Force refresh ‡∏à‡∏≤‡∏Å server ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    final snapshot = forceRefresh
        ? await query.get(const GetOptions(source: Source.server))
        : await query.get();

    return snapshot.docs
        .map((doc) => CameraReport.fromJson(doc.data()))
        .toList();
  }

  /// Get user's own reports (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
  static Future<List<CameraReport>> getUserReports(
      {bool forceRefresh = false}) async {
    final user = _auth.currentUser;
    if (user == null) return [];

    final query = _firestore
        .collection(_reportsCollection)
        .where('reportedBy', isEqualTo: user.uid)
        .orderBy('reportedAt', descending: true);

    // Force refresh ‡∏à‡∏≤‡∏Å server ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    final snapshot = forceRefresh
        ? await query.get(const GetOptions(source: Source.server))
        : await query.get();

    return snapshot.docs
        .map((doc) => CameraReport.fromJson(doc.data()))
        .toList();
  }

  /// Delete a report (admin function)
  static Future<void> deleteReport(String reportId) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('User not authenticated');

    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡πà‡∏≠‡∏ô (‡πÑ‡∏°‡πà timeout ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß)
      final reportDoc =
          await _firestore.collection(_reportsCollection).doc(reportId).get();

      if (!reportDoc.exists) throw Exception('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ');

      final report = CameraReport.fromJson(reportDoc.data()!);

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending
      if (report.reportedBy != user.uid) {
        throw Exception('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ');
      }
      if (report.status != CameraStatus.pending) {
        throw Exception('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ pending ‡πÑ‡∏î‡πâ');
      }

      // ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏•‡∏¢ (‡πÑ‡∏°‡πà timeout)
      await _firestore.collection(_reportsCollection).doc(reportId).delete();

      // ‡∏•‡∏ö votes ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á (‡πÑ‡∏°‡πà‡∏£‡∏≠)
      _deleteVotesInBackground(reportId);
    } catch (e) {
      throw Exception('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ: $e');
    }
  }

  /// ‡∏•‡∏ö votes ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
  static void _deleteVotesInBackground(String reportId) async {
    try {
      final votes = await _firestore
          .collection(_votesCollection)
          .where('reportId', isEqualTo: reportId)
          .get();

      for (final vote in votes.docs) {
        vote.reference.delete().catchError((e) {
          print('Warning: Could not delete vote ${vote.id}: $e');
        });
      }
    } catch (e) {
      print('Warning: Could not delete associated votes: $e');
    }
  }

  /// ‚ú® ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö UI)
  static Future<bool> checkCameraDeleted(String? cameraId) async {
    if (cameraId == null || cameraId.isEmpty) return true;
    return await _verifyCameraDeletion(cameraId);
  }

  /// üîß ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà verified ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debugging)
  static Future<void> forceDeleteVerifiedCameras() async {
    try {
      print('üîß === FORCE DELETE VERIFIED CAMERAS ===');

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ reports ‡∏ó‡∏µ‡πà verified ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó removedCamera
      final snapshot = await _firestore
          .collection(_reportsCollection)
          .where('status', isEqualTo: 'verified')
          .where('type', isEqualTo: 'removedCamera')
          .get();

      print('üìã Found ${snapshot.docs.length} verified removal reports');

      int processedCount = 0;
      int successCount = 0;
      int errorCount = 0;

      for (final doc in snapshot.docs) {
        try {
          final report = CameraReport.fromJson(doc.data());
          processedCount++;

          print(
              'üîß Processing report ${processedCount}/${snapshot.docs.length}:');
          print('   Report ID: ${report.id}');
          print('   Camera ID: ${report.selectedCameraId}');
          print('   Road: ${report.roadName}');

          if (report.selectedCameraId != null &&
              report.selectedCameraId!.isNotEmpty) {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            final cameraExists = await _firestore
                .collection('speed_cameras')
                .doc(report.selectedCameraId!)
                .get();

            if (cameraExists.exists) {
              print('   üóëÔ∏è Camera still exists - deleting now...');
              await _directDeleteCameraWithRetry(report.selectedCameraId!);
              successCount++;
              print('   ‚úÖ Camera deleted successfully');
            } else {
              print('   ‚úÖ Camera already deleted');
              successCount++;
            }
          } else {
            print('   ‚ö†Ô∏è No camera ID specified - skipping');
          }
        } catch (e) {
          errorCount++;
          print('   ‚ùå Error processing report: $e');
        }
      }

      print('üéâ === FORCE DELETE SUMMARY ===');
      print('   Total processed: $processedCount');
      print('   Successful: $successCount');
      print('   Errors: $errorCount');
    } catch (e) {
      print('‚ùå Error in force delete process: $e');
      rethrow;
    }
  }

  /// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Debug Auto-Verification ‡πÅ‡∏•‡∏∞ Promotion
  static Future<void> debugAutoVerificationProcess() async {
    print('üß™ === DEBUG AUTO-VERIFICATION PROCESS ===');

    try {
      // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà verified ‡πÅ‡∏•‡πâ‡∏ß
      print('üîç Step 1: Checking verified reports...');
      final verifiedReports = await getReportsByStatus(CameraStatus.verified);
      print('üìä Found ${verifiedReports.length} verified reports');

      for (final report in verifiedReports) {
        print('   Verified Report: ${report.roadName} (${report.id})');
        print('     Status: ${report.status}');
        print('     Type: ${report.type}');
        print('     Verified by: ${report.verifiedBy}');
        print('     Confidence: ${report.confidenceScore}');
      }

      // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å
      print('üîç Step 2: Checking main speed camera database...');
      final allCameras = await getAllSpeedCameras();
      print('üìä Found ${allCameras.length} cameras in main database');

      final communityCameras = allCameras
          .where((camera) =>
              camera.description?.contains('Community verified') == true)
          .toList();
      print('üèòÔ∏è Community cameras: ${communityCameras.length}');

      for (final camera in communityCameras) {
        print('   Community Camera: ${camera.roadName} (${camera.id})');
        print(
            '     Location: (${camera.location.latitude}, ${camera.location.longitude})');
        print('     Description: ${camera.description}');
      }

      // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ verified report ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      print('üîç Step 3: Checking for verified reports that need promotion...');
      final newCameraReports = verifiedReports
          .where((report) =>
              report.type == CameraReportType.newCamera &&
              report.verifiedBy == 'auto_system')
          .toList();

      print('üìä Found ${newCameraReports.length} verified new camera reports');

      for (final report in newCameraReports) {
        print('   Report to promote: ${report.roadName} (${report.id})');

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        final nearbyCamera = communityCameras.where((camera) {
          final distance = _calculateDistance(report.latitude, report.longitude,
              camera.location.latitude, camera.location.longitude);
          return distance <= 0.1; // 100 meters
        }).toList();

        if (nearbyCamera.isEmpty) {
          print(
              '     ‚ö†Ô∏è  This report should be promoted but camera not found!');
          print('     üîß Attempting manual promotion...');
          try {
            await _promoteToMainDatabase(report.id);
          } catch (e) {
            print('     ‚ùå Manual promotion failed: $e');
          }
        } else {
          print('     ‚úÖ Camera already exists: ${nearbyCamera.first.id}');
        }
      }

      print('üß™ === DEBUG PROCESS COMPLETE ===');
    } catch (e) {
      print('‚ùå Debug process failed: $e');
    }
  }

  /// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏ß‡∏ï‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
  static Future<void> createTestReportAndVotes({
    required double latitude,
    required double longitude,
    required String roadName,
    int speedLimit = 90,
    int numberOfUpvotes = 3,
    int numberOfDownvotes = 0,
  }) async {
    print('üß™ === CREATING TEST REPORT AND VOTES ===');

    try {
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö
      print('üìù Creating test report...');
      final reportId = await submitReport(
        latitude: latitude,
        longitude: longitude,
        roadName: roadName,
        speedLimit: speedLimit,
        type: CameraReportType.newCamera,
        description: 'TEST REPORT - Auto-generated for debugging',
      );

      print('‚úÖ Test report created: $reportId');
      print('   Location: ($latitude, $longitude)');
      print('   Road: $roadName');

      // ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏á‡∏Ñ‡πå
      await Future.delayed(const Duration(seconds: 2));

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏´‡∏ß‡∏ï‡∏ó‡∏î‡∏™‡∏≠‡∏ö
      print('üó≥Ô∏è  Creating test votes...');

      // Upvotes
      for (int i = 0; i < numberOfUpvotes; i++) {
        try {
          await submitVote(
            reportId: reportId,
            voteType: VoteType.upvote,
          );
          print('   ‚úÖ Upvote ${i + 1}/$numberOfUpvotes');
          await Future.delayed(const Duration(seconds: 1));
        } catch (e) {
          print('   ‚ùå Upvote ${i + 1} failed: $e');
        }
      }

      // Downvotes
      for (int i = 0; i < numberOfDownvotes; i++) {
        try {
          await submitVote(
            reportId: reportId,
            voteType: VoteType.downvote,
          );
          print('   ‚úÖ Downvote ${i + 1}/$numberOfDownvotes');
          await Future.delayed(const Duration(seconds: 1));
        } catch (e) {
          print('   ‚ùå Downvote ${i + 1} failed: $e');
        }
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•
      await Future.delayed(const Duration(seconds: 3));
      print('üîç Checking final result...');

      final reportDoc =
          await _firestore.collection(_reportsCollection).doc(reportId).get();
      if (reportDoc.exists) {
        final updatedReport = CameraReport.fromJson(reportDoc.data()!);
        print('üìä Final report status:');
        print('   Status: ${updatedReport.status}');
        print('   Upvotes: ${updatedReport.upvotes}');
        print('   Downvotes: ${updatedReport.downvotes}');
        print('   Confidence: ${updatedReport.confidenceScore}');
        print('   Verified by: ${updatedReport.verifiedBy}');
      }

      print('üß™ === TEST COMPLETE ===');
    } catch (e) {
      print('‚ùå Test failed: $e');
    }
  }

  /// Public method to manually trigger promotion for debugging
  static Future<void> debugPromoteReport(String reportId) async {
    print('üß™ === DEBUG PROMOTION FOR REPORT $reportId ===');
    try {
      await _promoteToMainDatabase(reportId);
      print('‚úÖ Debug promotion completed for $reportId');
    } catch (e) {
      print('‚ùå Debug promotion failed for $reportId: $e');
      rethrow;
    }
  }

  /// Handle camera removal report (verified removedCamera reports)
  static Future<void> _handleCameraRemovalReport(CameraReport report) async {
    try {
      print('üóëÔ∏è === STARTING CAMERA REMOVAL PROCESS ===');
      print('üîç Processing removal report: ${report.id}');
      print('üìç Target camera ID: ${report.selectedCameraId}');
      print('üìç Report location: (${report.latitude}, ${report.longitude})');

      // Step 1: Get camera ID from report
      String? cameraId = report.selectedCameraId;

      if (cameraId == null || cameraId.isEmpty) {
        print(
            '‚ö†Ô∏è No selectedCameraId provided, attempting location-based search...');

        // Fallback: search for camera by location
        final nearbyCameras = await getAllSpeedCameras();
        SpeedCamera? targetCamera;
        double minDistance = double.infinity;

        for (final camera in nearbyCameras) {
          final distance = _calculateDistance(
            report.latitude,
            report.longitude,
            camera.location.latitude,
            camera.location.longitude,
          );
          final distanceInMeters = distance * 1000;

          if (distanceInMeters <= 100 && distanceInMeters < minDistance) {
            minDistance = distanceInMeters;
            targetCamera = camera;
          }
        }

        if (targetCamera != null) {
          cameraId = targetCamera.id;
          print(
              '‚úÖ Found camera by location: ${targetCamera.roadName} (${cameraId}) at ${minDistance.toStringAsFixed(2)}m');
        } else {
          print('‚ùå No camera found within 100m of report location');
          throw Exception('Cannot identify camera to remove');
        }
      }

      // Step 2: Remove the community camera
      await _directDeleteCameraWithRetry(cameraId);

      // Step 3: Clean up related data
      print('üßπ Step 3: Cleaning up related report and vote data...');
      await _cleanupRelatedDataAfterRemoval(cameraId, report.id);

      // Step 4: Update report status with processing information
      await _firestore.collection(_reportsCollection).doc(report.id).update({
        'processedAt': FieldValue.serverTimestamp(),
        'processedBy': 'auto_removal_system',
        'removedCameraId': cameraId,
      });

      print('‚úÖ Camera removal report processed successfully');
      print('üóëÔ∏è === CAMERA REMOVAL PROCESS COMPLETE ===');
    } catch (e) {
      print('‚ùå Error processing camera removal report: $e');

      // Log the failure for debugging
      try {
        await _firestore.collection('camera_removal_failures').add({
          'reportId': report.id,
          'selectedCameraId': report.selectedCameraId,
          'latitude': report.latitude,
          'longitude': report.longitude,
          'error': e.toString(),
          'timestamp': FieldValue.serverTimestamp(),
        });
      } catch (logError) {
        print('‚ö†Ô∏è Failed to log removal failure: $logError');
      }

      rethrow;
    }
  }

  /// ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
  static Future<void> _cleanupRelatedDataAfterRemoval(
      String cameraId, String reportId) async {
    try {
      print('üßπ Cleaning up related data for camera $cameraId');

      // 1. ‡∏´‡∏≤‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ
      final relatedReportsQuery = await _firestore
          .collection(_reportsCollection)
          .where('selectedCameraId', isEqualTo: cameraId)
          .get();

      print('üìä Found ${relatedReportsQuery.docs.length} related reports');

      final batch = _firestore.batch();
      int archivedReports = 0;
      int deletedVotes = 0;

      // 2. Archive ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á
      for (final doc in relatedReportsQuery.docs) {
        final reportData = doc.data();

        // Archive to archived_camera_reports collection
        final archiveRef =
            _firestore.collection('archived_camera_reports').doc(doc.id);
        batch.set(archiveRef, {
          ...reportData,
          'archivedAt': FieldValue.serverTimestamp(),
          'archivedReason': 'camera_removed',
          'originalCameraId': cameraId,
        });

        // Delete from main collection
        batch.delete(doc.reference);
        archivedReports++;

        // 3. ‡∏´‡∏≤‡πÅ‡∏•‡∏∞ archive ‡πÇ‡∏´‡∏ß‡∏ï‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ
        final votesQuery = await _firestore
            .collection(_votesCollection)
            .where('reportId', isEqualTo: doc.id)
            .get();

        for (final voteDoc in votesQuery.docs) {
          final voteData = voteDoc.data();

          // Archive vote
          final voteArchiveRef =
              _firestore.collection('archived_camera_votes').doc(voteDoc.id);
          batch.set(voteArchiveRef, {
            ...voteData,
            'archivedAt': FieldValue.serverTimestamp(),
            'archivedReason': 'camera_removed',
            'originalReportId': doc.id,
          });

          // Delete original vote
          batch.delete(voteDoc.reference);
          deletedVotes++;
        }
      }

      // 4. ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
      final speedChangesQuery = await _firestore
          .collection('speed_limit_changes')
          .where('cameraId', isEqualTo: cameraId)
          .get();

      for (final doc in speedChangesQuery.docs) {
        batch.delete(doc.reference);
      }

      await batch.commit();

      print('‚úÖ Archived $archivedReports reports and $deletedVotes votes');
      print('‚úÖ Deleted ${speedChangesQuery.docs.length} speed limit changes');

      // 5. Archive ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
      await _archiveRemovedCameraData(cameraId, reportId);

      print('‚úÖ Cleanup completed successfully');
    } catch (e) {
      print('‚ö†Ô∏è Error during cleanup: $e');
      // ‡πÑ‡∏°‡πà throw error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏±‡∏î‡∏Ç‡∏ß‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å
    }
  }

  /// Archive ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
  static Future<void> _archiveRemovedCameraData(
      String cameraId, String reportId) async {
    try {
      final archiveData = {
        'cameraId': cameraId,
        'reportId': reportId,
        'archivedAt': FieldValue.serverTimestamp(),
        'reason': 'camera_removed_by_community',
        'removedBy': 'auto_system',
      };

      await _firestore.collection('archived_removed_cameras').add(archiveData);
      print('üì¶ Archived removed camera data');
    } catch (e) {
      print('‚ö†Ô∏è Failed to archive removed camera data: $e');
    }
  }

  /// Clean up related report and vote data after camera deletion/addition
  /// This prevents conflicts when recreating cameras at the same location
  static Future<void> _cleanupRelatedReportData(
      String cameraId, String processedReportId) async {
    try {
      print('üßπ === CLEANUP RELATED REPORT DATA ===');
      print('üéØ Camera ID: $cameraId');
      print('üéØ Processed Report ID: $processedReportId');

      // Option 1: Move to archive instead of deleting
      await _archiveProcessedReports(cameraId, processedReportId);

      // Option 2: Clean up votes for processed reports
      await _cleanupVotesForProcessedReports(cameraId, processedReportId);

      print('‚úÖ Cleanup completed successfully');
    } catch (e) {
      print('‚ö†Ô∏è Error during cleanup: $e');
      // Don't throw - cleanup failure shouldn't fail the main process
    }
  }

  /// Archive processed reports instead of deleting them
  static Future<void> _archiveProcessedReports(
      String cameraId, String processedReportId) async {
    try {
      print('üì¶ Archiving processed reports for camera: $cameraId');

      // Find reports related to this camera/location
      final reportQuery = await _firestore
          .collection(_reportsCollection)
          .where('selectedCameraId', isEqualTo: cameraId)
          .get();

      print('üìä Found ${reportQuery.docs.length} reports by cameraId');

      final batch = _firestore.batch();
      int archivedCount = 0;

      // Archive reports that match camera ID
      for (final doc in reportQuery.docs) {
        final reportData = doc.data();
        if (reportData['status'] == 'verified' || doc.id == processedReportId) {
          // Move to archived_reports collection
          final archiveRef =
              _firestore.collection('archived_camera_reports').doc(doc.id);
          batch.set(archiveRef, {
            ...reportData,
            'archivedAt': FieldValue.serverTimestamp(),
            'archivedReason': 'camera_processed',
            'originalCameraId': cameraId,
          });

          // Delete from main collection
          batch.delete(doc.reference);
          archivedCount++;
        }
      }

      if (archivedCount > 0) {
        await batch.commit();
        print('‚úÖ Archived $archivedCount reports to archived_camera_reports');
      } else {
        print('üìù No reports to archive');
      }
    } catch (e) {
      print('‚ö†Ô∏è Error archiving reports: $e');
    }
  }

  /// Clean up votes for processed reports
  static Future<void> _cleanupVotesForProcessedReports(
      String cameraId, String processedReportId) async {
    try {
      print('üó≥Ô∏è Cleaning up votes for processed camera: $cameraId');

      // Find votes for the processed report
      final voteQuery = await _firestore
          .collection('camera_votes')
          .where('reportId', isEqualTo: processedReportId)
          .get();

      print('üìä Found ${voteQuery.docs.length} votes for processed report');

      if (voteQuery.docs.isNotEmpty) {
        final batch = _firestore.batch();

        // Archive votes instead of deleting
        for (final voteDoc in voteQuery.docs) {
          final voteData = voteDoc.data();

          // Move to archived_votes collection
          final archiveRef =
              _firestore.collection('archived_camera_votes').doc(voteDoc.id);
          batch.set(archiveRef, {
            ...voteData,
            'archivedAt': FieldValue.serverTimestamp(),
            'archivedReason': 'report_processed',
            'originalReportId': processedReportId,
          });

          // Delete from main collection
          batch.delete(voteDoc.reference);
        }

        await batch.commit();
        print(
            '‚úÖ Archived ${voteQuery.docs.length} votes to archived_camera_votes');
      } else {
        print('üìù No votes to clean up');
      }
    } catch (e) {
      print('‚ö†Ô∏è Error cleaning up votes: $e');
    }
  }

  /// Clean up reports and votes for a specific location (alternative method)
  static Future<void> cleanupLocationReports({
    required double latitude,
    required double longitude,
    double radiusKm = 0.1, // 100 meters
  }) async {
    try {
      print('üßπ === CLEANUP REPORTS BY LOCATION ===');
      print('üìç Location: ($latitude, $longitude)');
      print('üìè Radius: ${radiusKm * 1000}m');

      // Get all reports and filter by location
      final allReportsQuery = await _firestore
          .collection(_reportsCollection)
          .where('status',
              isEqualTo: 'verified') // Only cleanup verified reports
          .get();

      final List<String> reportsToCleanup = [];

      for (final doc in allReportsQuery.docs) {
        final data = doc.data();
        final reportLat = data['latitude'] as double?;
        final reportLng = data['longitude'] as double?;

        if (reportLat != null && reportLng != null) {
          final distance =
              _calculateDistance(latitude, longitude, reportLat, reportLng);
          if (distance <= radiusKm) {
            reportsToCleanup.add(doc.id);
          }
        }
      }

      print(
          'üìä Found ${reportsToCleanup.length} verified reports to cleanup in radius');

      // Archive reports and their votes
      for (final reportId in reportsToCleanup) {
        await _cleanupRelatedReportData('location_based', reportId);
      }

      print('‚úÖ Location-based cleanup completed');
    } catch (e) {
      print('‚ö†Ô∏è Error in location-based cleanup: $e');
    }
  }

  /// ‚ú® ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  static Future<bool> _verifyCameraDeletion(String cameraId) async {
    try {
      print('üîç Verifying camera deletion for ID: $cameraId');
      final doc =
          await _firestore.collection('speed_cameras').doc(cameraId).get();
      final exists = doc.exists;
      print('üìç Camera $cameraId exists: $exists');
      return !exists; // return true ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á (‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à)
    } catch (e) {
      print('‚ùå Error verifying camera deletion: $e');
      return false; // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î error ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏•‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    }
  }

  /// ‚ú® ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
  static Future<void> _logDeletionError(
      String reportId, String? cameraId, String error) async {
    try {
      await _firestore.collection('camera_deletion_errors').add({
        'reportId': reportId,
        'cameraId': cameraId,
        'error': error,
        'timestamp': FieldValue.serverTimestamp(),
        'processedBy': 'auto_verification_system',
      });
      print('üìù Deletion error logged successfully');
    } catch (logError) {
      print('‚ö†Ô∏è Failed to log deletion error: $logError');
    }
  }

  /// ‚ú® ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö retry
  static Future<void> _directDeleteCameraWithRetry(String cameraId,
      {int maxRetries = 3}) async {
    print('üîÑ Starting camera deletion with retry for ID: $cameraId');

    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        print('üîÑ Deletion attempt $attempt/$maxRetries for camera $cameraId');

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏¢‡∏±‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö
        final cameraDoc =
            await _firestore.collection('speed_cameras').doc(cameraId).get();
        if (!cameraDoc.exists) {
          print('‚úÖ Camera $cameraId already deleted (attempt $attempt)');
          return;
        }

        // ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
        await _firestore.collection('speed_cameras').doc(cameraId).delete();
        print(
            'üóëÔ∏è Delete command sent for camera $cameraId (attempt $attempt)');

        // ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        await Future.delayed(Duration(seconds: attempt));

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        final isDeleted = await _verifyCameraDeletion(cameraId);
        if (isDeleted) {
          print('‚úÖ Camera $cameraId deleted successfully on attempt $attempt');

          // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
          await _firestore.collection('camera_deletion_log').add({
            'cameraId': cameraId,
            'deletionTimestamp': FieldValue.serverTimestamp(),
            'deletionMethod': 'auto_verification_with_retry',
            'deletedBy': 'auto_system',
            'reason': 'community_removal_vote_verified',
            'success': true,
            'attempts': attempt,
          });

          return;
        } else {
          print(
              '‚ö†Ô∏è Camera $cameraId still exists after deletion attempt $attempt');
        }
      } catch (e) {
        print('‚ùå Error on deletion attempt $attempt: $e');

        if (attempt == maxRetries) {
          // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error log ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
          await _firestore.collection('camera_deletion_log').add({
            'cameraId': cameraId,
            'deletionTimestamp': FieldValue.serverTimestamp(),
            'deletionMethod': 'auto_verification_with_retry',
            'success': false,
            'error': e.toString(),
            'attempts': attempt,
            'maxRetries': maxRetries,
          });
          rethrow;
        }
      }

      if (attempt < maxRetries) {
        // Exponential backoff
        final delaySeconds = attempt * 2;
        print('‚è≥ Waiting ${delaySeconds}s before retry...');
        await Future.delayed(Duration(seconds: delaySeconds));
      }
    }

    throw Exception(
        'Failed to delete camera $cameraId after $maxRetries attempts');
  }

  /// ‚ú® ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Firebase ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á (‡πÑ‡∏°‡πà‡∏¢‡∏∏‡πà‡∏á‡∏Å‡∏±‡∏ö UI)
  static Future<void> _directDeleteCamera(String cameraId) async {
    try {
      print('üóëÔ∏è === DIRECT CAMERA DELETION ===');
      print('üéØ Target Camera ID: $cameraId');

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      final cameraDoc =
          await _firestore.collection('speed_cameras').doc(cameraId).get();

      if (!cameraDoc.exists) {
        print('‚ö†Ô∏è Camera $cameraId does not exist - may already be deleted');
        return;
      }

      // ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å speed_cameras collection
      await _firestore.collection('speed_cameras').doc(cameraId).delete();
      print('‚úÖ Camera $cameraId deleted from speed_cameras collection');

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å log ‡∏Å‡∏≤‡∏£‡∏•‡∏ö
      await _firestore.collection('camera_deletion_log').add({
        'cameraId': cameraId,
        'deletionTimestamp': FieldValue.serverTimestamp(),
        'deletionMethod': 'direct_deletion_after_verification',
        'deletedBy': 'auto_system',
        'reason': 'community_removal_vote_verified',
        'success': true,
      });
      print('‚úÖ Deletion logged successfully');

      print('üéâ === DIRECT CAMERA DELETION COMPLETED ===');
    } catch (e) {
      print('‚ùå Error in direct camera deletion: $e');

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error log
      try {
        await _firestore.collection('camera_deletion_log').add({
          'cameraId': cameraId,
          'deletionTimestamp': FieldValue.serverTimestamp(),
          'deletionMethod': 'direct_deletion_after_verification',
          'success': false,
          'error': e.toString(),
        });
      } catch (logError) {
        print('‚ö†Ô∏è Failed to log deletion error: $logError');
      }

      rethrow;
    }
  }

  /// ‚ú® ‡∏•‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ Camera ID)
  static Future<void> _deleteByLocation(
      double latitude, double longitude) async {
    try {
      print('üóëÔ∏è === LOCATION-BASED CAMERA DELETION ===');
      print('üìç Target location: ($latitude, $longitude)');

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ 100 ‡πÄ‡∏°‡∏ï‡∏£
      final allCameras = await getAllSpeedCameras();
      SpeedCamera? targetCamera;
      double minDistance = double.infinity;

      for (final camera in allCameras) {
        final distance = _calculateDistance(
          latitude,
          longitude,
          camera.location.latitude,
          camera.location.longitude,
        );
        final distanceInMeters = distance * 1000;

        if (distanceInMeters <= 100 && distanceInMeters < minDistance) {
          minDistance = distanceInMeters;
          targetCamera = camera;
        }
      }

      if (targetCamera != null) {
        print(
            'üéØ Found camera: ${targetCamera.roadName} (${targetCamera.id}) at ${minDistance.toStringAsFixed(2)}m');
        await _directDeleteCamera(targetCamera.id);
        print('‚úÖ Location-based deletion completed');
      } else {
        print('‚ùå No camera found within 100m of specified location');
        throw Exception(
            'No camera found within 100m of location ($latitude, $longitude)');
      }
    } catch (e) {
      print('‚ùå Error in location-based deletion: $e');
      rethrow;
    }
  }

  /// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô speedChanged
  static Future<void> _updateCameraSpeedLimit(CameraReport report) async {
    if (report.type != CameraReportType.speedChanged ||
        report.selectedCameraId == null) {
      return;
    }

    try {
      print('‚ö° Updating speed limit for camera: ${report.selectedCameraId}');
      print('   New speed limit: ${report.speedLimit} km/h');

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏°
      final cameraRef =
          _firestore.collection('speed_cameras').doc(report.selectedCameraId);
      final cameraDoc = await cameraRef.get();

      int? oldSpeedLimit;
      if (cameraDoc.exists) {
        final cameraData = cameraDoc.data() as Map<String, dynamic>;
        oldSpeedLimit = cameraData['speedLimit'] as int?;
      }

      await cameraRef.update({
        'speedLimit': report.speedLimit,
        'lastUpdated': FieldValue.serverTimestamp(),
        'updatedBy': 'community_vote',
        'sourceReport': report.id,
      });

      print('‚úÖ Speed limit updated successfully');

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
      await _firestore.collection('speed_limit_changes').add({
        'cameraId': report.selectedCameraId,
        'oldSpeed': oldSpeedLimit,
        'newSpeed': report.speedLimit,
        'changedAt': FieldValue.serverTimestamp(),
        'changedBy': 'auto_system',
        'reportId': report.id,
        'confidence': report.confidenceScore,
        'reporterUserId': report.reportedBy,
      });

      print('üìä Speed limit change logged successfully');
    } catch (e) {
      print('‚ùå Error updating speed limit: $e');
      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏ß‡∏ï‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
      await _logSpeedUpdateError(
          report.id, report.selectedCameraId, e.toString());
    }
  }

  /// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å error ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
  static Future<void> _logSpeedUpdateError(
      String reportId, String? cameraId, String error) async {
    try {
      await _firestore.collection('speed_update_errors').add({
        'reportId': reportId,
        'cameraId': cameraId,
        'error': error,
        'timestamp': FieldValue.serverTimestamp(),
      });
      print('üìù Speed update error logged');
    } catch (e) {
      print('‚ö†Ô∏è Failed to log speed update error: $e');
    }
  }
}

// Remove the local LatLng class since we're using latlong2
